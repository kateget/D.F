1. '|' 多选分支 gr[ea]y 可以写作字符组 grey|gray 或者 多选项 gr(a|e)y
  字符组只能匹配单个字符，多选项可以匹配任意长度的文本，每个多选项可能匹配的文本都是独立的
 
2.反向引用：例如，把最后一个‘the’替换成特殊的元字符序列\1 得到：\b([A-Za-z]+)\s+\1\b
  js中反向引用写法为：'i is man'.replace(/(i)\s(is)\s(man)/,'$1$2')  结果：iis
  
3.'-' 表示连字符的时候，必须放在字符开头，否则会表示范围，[-0-9]

4.环视：环视结构不匹配任何字符，只匹配文本中的特定位置

--1--: (肯定)顺序环视(?=...)  *子表达式能够匹配右侧文本
顺序环视会检查子表达式是否匹配，但它只寻找能匹配的位置，而不会真正“占用”这些字符。
  例如：(?=\d) 表示如果当前位置右边的字符是数字则匹配成功
  
  例子一：'by jeffrey friedl.'.match(/(?=jeffrey)jeff/)
    (?=jeffrey)jeff 与 jeff(?=rey)是等价的
    他们的结合顺序非常重要，jeff(?=jeffrey)不会匹配上面的例子，他只会匹配后面紧跟有"jeffrey"的“jeff”.
  
  例子二： 'jeffs'.replace(/(?<=\bjeff)(?=s\b)/,"'")   结果："jeff's"
    他的意思是：找到这样一个位置，它紧接着'jeff'之后，在's'之前，插入撇号
    'jeffs'.replace(/(?=s\b)(?<=\bjeff)/,"'") 结果也是一样
    (?=s\b)与(?<=\bjeff)先后顺序无关紧要，无论是“先检查左边，再检查右边”还是相反，在同一个位置检测都必须成功，整个匹配才算成功
  
--2--： (肯定)逆序环视(?<=...)  *子表达式能够匹配左侧文本
  例如：(?<=\d)
  
  例子一： 右边数字的个数正好是3的倍数，实现 123456789 ---> 123,456,789
    '123456789'.replace(/(?<=\d)(?=(\d\d\d)+$)/g,',')
    (?<=\d)表示的是,数字后，(?=(\d\d\d)+$)表示3x位数字前，加上$是为了确保数字后面不存在其他字符(保证'正好')
    优化：/(?<=\d)(?:(?=(\d\d\d)+$))/ 好处在于：不用担心捕获关联的$1是否被用到，而且效率更高，因为引擎不用记忆捕获的文本。
    
单词分界符和否定环视
  'the population of 298444215 is growing'.replace(/(?<=\d)(?:(?=(\d\d\d)+$))/g,',')
  当把插入逗号的正则应用到很长的字符串中，会出现匹配不到，参考书籍：65页，去掉$匹配结果为：1,2,3,4,5,6,789，显然不符合
  \b 分界符的意思是：一侧如此这般，另一侧如此那般，例，在此位置的一侧是单词(或数字)，另一侧不是
  

--3--: (否定)顺序环视 (?!...)  *子表达式不能匹配右侧文本

如果单词分界符的意思是：一侧是\w，另一侧不是\w 我们可以用 (?<!\w)(?=\w)来表示单词起始分界符，用(?<=\w)(?!\w)表示结束分界符，两者结合就是
(?<!\w)(?=\w) | (?<=\w)(?!\w) 就等价于 \b






  
